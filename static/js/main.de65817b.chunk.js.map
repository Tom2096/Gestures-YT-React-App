{"version":3,"sources":["components/Detect.js","components/Draw.js","components/Predict.js","App.js","index.js"],"names":["model","webcamRef","canvasRef","a","current","video","readyState","videoWidth","videoHeight","width","height","estimateHands","hand","Detect","Draw","prediction","ctx","landmarks","forEach","landmark","x","y","beginPath","arc","Math","PI","fillStyle","fill","labels_dict","0","1","2","3","4","normalize","length","x_max","x_min","y_max","y_min","max","min","w","h","data","push","maxIdx","array","idx","i","input","Tensor","run","outputMap","outputTensor","values","next","value","label","Predict","style","position","top","left","right","bottom","margin","zIndex","playList","App","useState","tfModel","setTfModel","onnxModel","setOnnxModel","showCam","setShowCam","Date","ts","setTs","queue","setQueue","action","setAction","percent","setPercent","isPlaying","setIsPlaying","videoIdx","setVideoIdx","useRef","handpose","net","console","log","sess","InferenceSession","loadModel","nextVideo","useEffect","Init","intervalId","setInterval","clearInterval","then","getContext","c_queue","pop","unshift","counter","c_idx","previousVideo","round","handleQueue","className","Icon","onMouseEnter","onMouseLeave","name","ref","playing","onEnded","onPause","url","CSSTransition","in","appear","unmountOnExit","timeout","classNames","background","text","strokeWidth","styles","buildStyles","pathTransitionDuration","backgroundColor","pathColor","trailColor","textColor","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.de65817b.chunk.js","sourcesContent":["import * as tf from '@tensorflow/tfjs';\r\nimport * as handpose from '@tensorflow-models/handpose';\r\n\r\nasync function Detect(model, webcamRef, canvasRef) {\r\n    if (\r\n        typeof webcamRef.current !== 'undefined' &&\r\n        webcamRef.current !== null &&\r\n        webcamRef.current.video.readyState === 4\r\n    ) {\r\n        const video = webcamRef.current.video;\r\n        const videoWidth = webcamRef.current.video.videoWidth;\r\n        const videoHeight = webcamRef.current.video.videoHeight;\r\n  \r\n        webcamRef.current.video.width = videoWidth;\r\n        webcamRef.current.video.height = videoHeight;\r\n\r\n        canvasRef.current.width = videoWidth;\r\n        canvasRef.current.height = videoHeight;\r\n\r\n        const hand = await model.estimateHands(video);\r\n        return hand;\r\n    }\r\n}\r\n\r\nexport default Detect;","function Draw(prediction, ctx) {\r\n\r\n    const landmarks = prediction.landmarks;\r\n\r\n    landmarks.forEach(landmark => {\r\n        const x = landmark[0];\r\n        const y = landmark[1];\r\n        \r\n        ctx.beginPath();\r\n        ctx.arc(x, y, 6, 0, 3 * Math.PI);\r\n        ctx.fillStyle = \"black\";\r\n        ctx.fill();\r\n\r\n    });\r\n}\r\n\r\nexport default Draw;","import {Tensor, InferenceSession} from 'onnxjs';\r\n\r\nconst labels_dict = {\r\n    0: 'play',\r\n    1: 'pause',\r\n    2: 'previous',\r\n    3: 'next',\r\n    4: 'ok',\r\n}\r\n\r\nfunction normalize(landmarks) {\r\n\r\n    if (landmarks.length === 0) {\r\n        return null;\r\n    }\r\n\r\n    var x_max, x_min, y_max, y_min;\r\n\r\n    x_max = x_min = landmarks[0][0];\r\n    y_max = y_min = landmarks[0][1];\r\n\r\n    landmarks.forEach(landmark => {\r\n        x_max = Math.max(x_max, landmark[0]);\r\n        x_min = Math.min(x_min, landmark[0]);\r\n\r\n        y_max = Math.max(y_max, landmark[1]);\r\n        y_min = Math.min(y_min, landmark[1]);\r\n    })\r\n\r\n    const w = x_max - x_min;\r\n    const h = y_max - y_min;\r\n\r\n    const data = [];\r\n\r\n    landmarks.forEach(landmark => {\r\n        const x = (landmark[0] - x_min) / w;\r\n        const y = (landmark[1] - y_min) / h;\r\n        data.push(x, y);\r\n    })\r\n    \r\n    return data;\r\n}\r\n\r\nfunction maxIdx(array) {\r\n    if (array.length === 0) {\r\n        return -1;\r\n    }\r\n\r\n    var max = array[0];\r\n    var idx = 0;\r\n\r\n    for (var i = 0; i < array.length; i++) {\r\n        if (array[i] > max) {\r\n            max = array[i];\r\n            idx = i;\r\n        }\r\n    }\r\n\r\n    return idx;\r\n}\r\n\r\nasync function Predict(model, prediction) {\r\n\r\n    const landmarks = prediction.landmarks;\r\n\r\n    const input = [new Tensor (normalize(landmarks), 'float32', [1, 21, 2])];\r\n    const outputMap = await model.run(input);\r\n    const outputTensor = outputMap.values().next().value;\r\n\r\n    const label = labels_dict[maxIdx(outputTensor.data)];\r\n\r\n    return label; \r\n}\r\n\r\nexport default Predict;\r\n","import React, { useEffect, useRef, useState } from 'react';\nimport Webcam from 'react-webcam'; \nimport ReactPlayer from 'react-player';\nimport {CSSTransition} from 'react-transition-group';\n\nimport * as tf from '@tensorflow/tfjs';\nimport * as handpose from '@tensorflow-models/handpose';\nimport {InferenceSession} from 'onnxjs';\n\nimport Detect from './components/Detect.js';\nimport Draw from './components/Draw.js';\nimport Predict from './components/Predict.js';\n\nimport {CircularProgressbar, buildStyles} from 'react-circular-progressbar';\nimport 'react-circular-progressbar/dist/styles.css';\nimport { Icon } from 'semantic-ui-react';\nimport 'semantic-ui-css/semantic.min.css';\n\nconst style = {\n  position: 'absolute',\n  top: 0,\n  left: 0,\n  right: 0,\n  bottom: 0,\n  margin: 'auto',\n  width: 640,\n  height: 480,\n  zIndex: 9,\n}\n\nconst sensitivity = 15;\n\nconst playList = [\n  'https://www.youtube.com/watch?v=VY1eFxgRR-k',\n  'https://www.youtube.com/watch?v=aJOTlE1K90k',\n  'https://www.youtube.com/watch?v=DGzy8FE1Rhk',\n  'https://www.youtube.com/watch?v=ycy30LIbq4w',\n  'https://www.youtube.com/watch?v=Jqs5EaAaueA',\n]\n\nfunction App() {\n\n  const [tfModel, setTfModel] = useState(null);\n  const [onnxModel, setOnnxModel] = useState(null);\n\n  const [showCam, setShowCam] = useState(false);\n\n  const [ts, setTs] = useState(new Date());\n\n  const [queue, setQueue] = useState([]);\n  const [action, setAction] = useState(null);\n  const [percent, setPercent] = useState(0);\n\n  const [isPlaying, setIsPlaying] = useState(true);\n  const [videoIdx, setVideoIdx] = useState(0);\n\n  const webcamRef = useRef(null);\n  const canvasRef = useRef(null);\n\n  // INIT ------------------------------------------------------------------------------//\n\n  useEffect(() => {  \n    Init();\n    const intervalId = setInterval(() => setTs(new Date()), 100);\n    return () => clearInterval(intervalId);\n  }, [])\n\n  async function Init() {\n    const net = await handpose.load();\n    setTfModel(net);\n    console.log('[-] ... Loaded Model | TensorFlow');\n\n    const sess = new InferenceSession();\n    await sess.loadModel('./model.onnx');\n    setOnnxModel(sess);\n    console.log('[-] ... Loaded Model | Onnx');\n\n    console.log('[-] ... Models Loaded Sucessfully');\n  }\n  \n  // DETECT -----------------------------------------------------------------------------//\n\n  useEffect(() => {\n    if ( tfModel && onnxModel) {\n      Detect(tfModel, webcamRef, canvasRef).then(\n        hand => {\n          if (hand && hand.length > 0) {\n            const ctx = canvasRef.current.getContext('2d');\n            Draw(hand[0], ctx);\n            Predict(onnxModel, hand[0]).then(\n              prediction => {\n                handleQueue(prediction);\n              }\n            )\n          }\n          setQueue([]);\n          setAction(null);\n          setPercent(0);\n        }\n      )\n    }\n  }, [ts])\n\n  function handleQueue (prediction) {\n\n    var c_queue = [...queue];\n\n    if (queue.length > sensitivity) {\n      c_queue.pop();\n    } \n    c_queue.unshift(prediction);\n    \n    var counter = 0;\n    for (var i = 0; i < sensitivity; i++) {\n      if ((i === c_queue.length) || (i !== 0 && c_queue[i - 1] !== c_queue[i])) {\n        break;\n      }\n      counter += 1;\n    }\n    \n    if (counter === sensitivity) {\n      if (action === 'play') {\n        setIsPlaying(true);\n      }\n      if (action === 'pause') {\n        setIsPlaying(false);\n      }\n      if (action === 'previous') {\n        previousVideo();\n      }\n      if (action === 'next') {\n        nextVideo();\n      }\n      \n      console.log('[-] ... Action Completed | ' + action);\n      \n      c_queue = [];  \n    }\n    \n    setQueue(c_queue);\n    setAction(c_queue[0]);\n    setPercent(Math.round((counter / sensitivity) * 100));\n  }\n\n  // PLAYLIST ----------------------------------------------------------------------------//\n\n  function nextVideo() {\n    const c_idx = videoIdx;\n    if (c_idx === playList.length - 1) {\n      setVideoIdx(0);\n    } else {\n      setVideoIdx(c_idx + 1);\n    }\n  }\n\n  function previousVideo() {\n    const c_idx = videoIdx;\n    if (c_idx === 0) {\n      setVideoIdx(playList.length - 1);\n    } else {\n      setVideoIdx(c_idx - 1);\n    }\n  }\n\n  // RENDER ------------------------------------------------------------------------------//\n\n  return (\n    <div className=\"app\">\n\n      <Icon\n        onMouseEnter={() => {setShowCam(true)}}\n        onMouseLeave={() => {setShowCam(false)}} \n        name='record' \n      />\n\n      <Webcam\n        className={'webcam ' + (showCam ? 'active' : '')}\n        ref={webcamRef}\n        style={style}\n      />\n\n      <canvas \n        ref={canvasRef} \n        style={style}>\n      </canvas>\n\n      <div className={'overlay ' + (showCam ? 'active' : '')}>\n      </div>\n\n      <div className='content'>\n        <div className='video-player'>\n          <div className='player-wrapper'>\n            <ReactPlayer\n              playing={isPlaying}\n              onEnded={nextVideo}\n              onPause={() => setIsPlaying(false)}\n              className='react-player'\n              url={playList[videoIdx]}\n              width='100%'\n              height='100%'\n            />\n            <CSSTransition\n              in={action !== null}\n              appear={false}\n              unmountOnExit={true}\n              timeout={400}\n              classNames={'fade'}\n            >\n              <CircularProgressbar\n                background\n                value={percent}\n                text={action}\n                strokeWidth={5}\n                styles={buildStyles({\n                  pathTransitionDuration: 0.1,\n                  backgroundColor: 'rgba(0 ,0, 0, 0.8)',\n                  pathColor: 'white',\n                  trailColor: 'black',\n                  textColor: 'white',\n                })}\n              />\n            </CSSTransition>\n            \n          </div>\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport App from './App';\n\nimport './index.css';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}